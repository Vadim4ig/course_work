<p align="center">Министерство образования, науки и молодежной политики Республики Коми</p>

<p align="center">ГПОУ "Сыктывкарский политехнический техникум"</p>






<p align="center">Курсовая работа</p>



<p align="center">Тема: База данных Издательства. Подсистема служба маркетинга</p>















<p align="right"> выполнил </p>

<p align="right">студент 4 курса </p>

<p align="right">414 группы </p>

<p align="right">Овчинникова Арина ...</p>



<p align="right">проверил</p>

<p align="right">Пунгин И.В.</p>

<p align="right">дата проверки: ______________</p>










<p align="center">Сыктывкар, 2025</p>






# Задание на курсовую работу по МДК 11.01 "Технология разработки и защиты баз данных"

Специальность: <ins> 09.02.07 "Информационные системы и программирование"  </ins>

Тема курсовой работы:База данных Издательства. Подсистема служба маркетинга

Срок представления работы к защите: <ins> ... марта 2025 года. </ins>

Перечень подлежащих разработке вопросов:

1. Анализ предметной области. Постановка задачи.

    1.1. Описание предметной области и функции решаемых задач.

    1.2. Перечень входных данных.

    1.3. Перечень выходных данных

    1.4. Ограничения предметной области (если таковые имеются).

    1.5. Взаимодействие с другими программами.

3. Инфологическая (концептуальная) модель базы данных.

    2.1. Выделение информационных объектов.

    2.2. Определение атрибутов объектов.

    2.3. Определение отношений и мощности отношений между объектами.

    2.4. Построение концептуальной модели.

4. Логическая структура БД.

5. Физическая структура базы данных.

6. Реализация проекта в среде конкретной СУБД.

    6.1. Создание таблиц и индексов.

    6.2. Создание представлений и функций.

    5.3. Разработка интерфейса.

    5.4. Назначение прав доступа.

    5.5. Разработка стратегии резервного копирования базы данных.


Руководитель работы __________________ <ins> И. В. Пунгин </ins>

Задание принял к исполнению _______________________________ <ins> В. А. Попов </ins>




## <a id="content">Содержание</a>

1. [Введение](#introduction)
    - [Цель работы](#target)
    - [Задачи работы](#tasks)
2. [Основная часть](#main)
    - [Анализ предметной области. Постановка задачи](#analysis)
    - [Инфологическая (концептуальная) модель базы данных](#infological_model)
    - [Логическая структура БД](#logical_structure)
    - [Физическая структура базы данных](#physical_structure)
    - [Реализация проекта в среде конкретной СУБД](#project_realization)
3. [Заключение](#conclusion)
4. [Список использованных информационных источников](#literature)
5. [Приложения](#applications)



## <a id="introduction">Введение</a>  

В условиях цифровой трансформации издательского бизнеса эффективное управление маркетинговыми процессами становится ключевым фактором конкурентоспособности. Автоматизация анализа потребительского спроса, оптимизация рекламных бюджетов и контроль эффективности кампаний требуют внедрения специализированной базы данных (БД), что обуславливает актуальность разработки подсистемы маркетинга для издательства. Такая система должна обеспечивать централизованное хранение данных о маркетинговых активностях, включая рекламные кампании, материалы (баннеры, email-рассылки), взаимодействие с клиентами, а также интеграцию с данными о продажах и авторах.  

Внедрение автоматизированной базы данных позволит:  
- Сократить время на ручной учёт и анализ данных.  
- Минимизировать ошибки при планировании бюджета кампаний.  
- Оперативно оценивать ROI (возврат на инвестиции) для каждого рекламного канала.  
- Персонализировать взаимодействие с клиентами на основе их предпочтений и истории покупок.  

Ключевая задача проекта — создание системы, которая объединит данные о маркетинговых кампаниях, материалах, заказах и клиентах, обеспечив:  
- Автоматическое обновление остатков книг на складе при запуске рекламных акций.  
- Формирование отчётов по конверсии, динамике спроса и эффективности каналов продвижения.  
- Интеграцию с CRM-системами для анализа лояльности клиентов.  
- Защиту конфиденциальных данных (бюджеты, контакты авторов) через ролевую модель доступа.  

Разработанная подсистема станет инструментом для:  
- Прогнозирования спроса на книги с использованием исторических данных.  
- Оптимизации рекламных бюджетов за счёт анализа ROI.  
- Ускорения вывода новых изданий на рынок благодаря автоматизации процессов.  

Таким образом, курсовая работа направлена на создание базы данных, которая не только автоматизирует текущие задачи маркетинговой службы издательства, но и станет основой для внедрения AI-решений в будущем, таких как прогнозирование трендов или генерация персональных рекомендаций для клиентов.


## <a id="target">Цель работы</a>  

**Целью курсовой работы** является разработка базы данных для подсистемы маркетинга издательства, которая обеспечит автоматизацию процессов планирования, анализа и оптимизации маркетинговых активностей. В рамках работы предполагается:  

1. **Создание структуры базы данных**:  
   Разработать схему БД, отражающую ключевые сущности маркетинговой деятельности издательства: рекламные кампании, маркетинговые материалы (баннеры, email-рассылки), данные о клиентах, заказах и авторах. Обеспечить целостность данных за счёт нормализации таблиц, установки связей (например, между кампаниями и материалами) и ограничений (проверка бюджетов, дат).  

2. **Реализация функционала для управления маркетинговыми процессами**:  
   Создать механизмы для:  
   - Регистрации новых кампаний с привязкой к материалам и авторам.  
   - Учёта затрат на рекламу и анализа ROI (возврата на инвестиции).  
   - Автоматического обновления данных о продажах при запуске акций.  

3. **Разработка аналитических инструментов**:  
   Реализовать представления и запросы для:  
   - Анализа эффективности кампаний по ключевым метрикам (конверсия, охват, CTR).  
   - Формирования отчётов по динамике спроса на книги в разрезе жанров и авторов.  
   - Прогнозирования потребности в тиражах на основе исторических данных.  

4. **Обеспечение безопасности и ролевого доступа**:  
   Внедрить модель разграничения прав:  
   - **Маркетологи** — управление кампаниями и материалами.  
   - **Администраторы** — полный контроль над данными, включая настройку прав.  
   - **Клиенты** — доступ к персонализированным предложениям через внешние интерфейсы.  
   Защитить конфиденциальные данные (бюджеты, контакты авторов) через шифрование и аудит изменений.  

5. **Интеграция с внешними системами**:  
   Настроить взаимодействие с CRM-системами для анализа лояльности клиентов и электронными торговыми площадками для автоматического обновления остатков книг.  

6. **Документирование системы**:  
   Подготовить:  
   - Техническую документацию (ER-диаграммы, описание таблиц, SQL-скрипты).  
   - Руководство пользователя для маркетологов с примерами работы (создание кампаний, анализ ROI).  
   - API-документацию для интеграции с платформами электронной коммерции.  

**Итоговая цель** — создание системы, которая не только автоматизирует текущие задачи маркетинговой службы, но и станет основой для:  
- Оптимизации рекламных бюджетов за счёт анализа данных в реальном времени.  
- Персонализации взаимодействия с клиентами через сегментацию аудитории.  
- Внедрения AI-решений для прогнозирования спроса и генерации контента.  

Таким образом, разработанная база данных позволит издательству повысить эффективность маркетинговых стратегий, сократить издержки и укрепить позиции на конкурентном рынке.


## <a id="analysis">Анализ предметной области. Постановка задачи</a>  

### 1. **Описание предметной области и функции решаемых задач**  
   - **Предметная область** данной работы — управление маркетинговой деятельностью издательства, включая планирование рекламных кампаний, создание маркетинговых материалов (баннеры, email-рассылки, соцсети), анализ эффективности продвижения книг и взаимодействие с клиентами. Система направлена на автоматизацию процессов, связанных с продвижением изданий, что позволит оптимизировать рекламные бюджеты, повысить конверсию и улучшить взаимодействие с целевой аудиторией. Основная цель — увеличение продаж за счёт точного таргетинга, анализа данных о спросе и оперативного управления кампаниями.  
   - **Функции решаемых задач:**  
     - **Управление маркетинговыми кампаниями:**  
       - Создание и редактирование кампаний с указанием бюджета, сроков, целевой аудитории.  
       - Привязка материалов (баннеры, видео, тексты) к конкретным кампаниям.  
     - **Анализ эффективности:**  
       - Расчёт метрик: ROI (возврат на инвестиции), CTR (кликабельность), конверсия в продажи.  
       - Формирование отчётов по эффективности каналов продвижения (соцсети, email, сайт).  
     - **Взаимодействие с клиентами:**  
       - Сегментация аудитории на основе предпочтений (жанры книг, история покупок).  
       - Автоматизация персонализированных рассылок и рекомендаций.  
     - **Интеграция с данными о книгах и авторах:**  
       - Учёт информации о книгах (жанр, тираж, дата публикации) и авторах (контакты, участие в промо-акциях).  
       - Связь кампаний с конкретными изданиями или авторами.  
     - **Контроль бюджета:**  
       - Мониторинг расходов на рекламу в реальном времени.  
       - Автоматические предупреждения о превышении лимитов.  
     - **Разграничение прав доступа:**  
       - *Администратор* — полный контроль над данными, настройка ролей, доступ к финансовой аналитике.  
       - *Маркетолог* — создание и управление кампаниями, просмотр метрик.  
       - *Клиент* — доступ к персонализированным предложениям и истории заказов.  

### 2. **Постановка задачи**  
Разработать базу данных и приложение, которые:  
- Автоматизируют учёт маркетинговых активностей от планирования до анализа результатов.  
- Обеспечивают целостность данных через:  
  - Уникальность идентификаторов кампаний и материалов.  
  - Проверку корректности дат (окончание кампании не раньше начала).  
  - Контроль бюджета (запрет отрицательных значений, лимиты расходов).  
- Предоставляют инструменты для:  
  - Прогнозирования спроса на книги на основе исторических данных.  
  - Сравнения эффективности разных каналов продвижения (соцсети vs. email).  
- Интегрируются с внешними системами:  
  - Импорт данных о продажах из CRM.  
  - Экспорт метрик в Excel для формирования презентаций.  
- Поддерживают многопользовательскую работу:  
  - Параллельное редактирование кампаний с блокировкой конфликтующих изменений.  
  - Ролевая модель с разным уровнем доступа к финансовым и клиентским данным.  

**Пример реализации:**  
- Таблица `campaigns` хранит данные о рекламных активностях, включая бюджет, сроки и привязку к книгам.  
- Триггеры автоматически обновляют остатки бюджета при добавлении новых материалов.  
- Представление `campaign_performance` агрегирует данные по ROI и конверсии для каждой кампании.  
- Клиентский интерфейс позволяет фильтровать книги по жанрам и получать персонализированные рекомендации на основе истории покупок.  

Этот подход позволит издательству сократить время на ручные расчёты, повысить точность прогнозов и усилить вовлечённость аудитории.



## <a id="input">2. Перечень входных данных</a>  
Для корректной работы маркетинговой подсистемы издательства требуются следующие входные данные:  

---

### **Данные о маркетинговых кампаниях:**  
  - Идентификатор кампании (ID).  
  - Название кампании.  
  - Тип кампании (например, "Email-рассылка", "Соцсети", "Печатная реклама").  
  - Бюджет (в формате DECIMAL).  
  - Дата начала и окончания.  
  - Целевая аудитория (демография, предпочтения).  
  - Идентификатор ответственного маркетолога (внешний ключ к таблице `users`).  
  - Список привязанных книг/авторов (внешние ключи к таблицам `books` и `authors`).  

---

### **Данные о маркетинговых материалах:**  
  - Идентификатор материала (ID).  
  - Тип материала ("Баннер", "Видео", "Текст для рассылки", "Landing Page").  
  - Контент (URL изображения, текст, HTML-шаблон).  
  - Дата создания и публикации.  
  - Идентификатор кампании (внешний ключ к таблице `campaigns`).  
  - Статус ("Черновик", "Опубликован", "Архив").  

---

### **Данные о клиентах:**  
  - Идентификатор клиента (ID).  
  - Имя, фамилия, email, телефон.  
  - Предпочтения (любимые жанры книг, история покупок).  
  - Дата последнего взаимодействия.  
  - Сегмент аудитории ("Новый", "Постоянный", "Неактивный").  

---

### **Данные о книгах и авторах:**  
  - Идентификатор книги (ID).  
  - Название, жанр, дата публикации.  
  - Тираж, цена, текущий остаток на складе.  
  - Идентификатор автора (внешний ключ к таблице `authors`).  
  - Рейтинг продаж и отзывов.  

  - Идентификатор автора (ID).  
  - Имя, фамилия, контактные данные.  
  - Биография, участие в промо-акциях.  
  - Список опубликованных книг (внешние ключи к таблице `books`).  

---

### **Данные о событиях (взаимодействия с клиентами):**  
  - Идентификатор события (ID).  
  - Тип события ("Покупка", "Подписка на рассылку", "Открытие email", "Клик по баннеру").  
  - Идентификатор клиента (внешний ключ к таблице `customers`).  
  - Идентификатор материала/кампании (внешние ключи к таблицам `marketing_materials` и `campaigns`).  
  - Дата и время события.  
  - Дополнительные метрики (например, длительность просмотра видео).  

---

### **Данные о пользователях системы:**  
  - Идентификатор пользователя (ID).  
  - Логин и хеш пароля (для авторизации).  
  - Роль ("Администратор", "Маркетолог", "Клиенты").  
  - Привязанные кампании (для роли "Маркетолог").  
  - Права доступа к финансовым отчётам (для роли "Клиенты").  

---

### **Данные для аналитики:**  
  - Ключевые метрики эффективности:  
    - ROI (Return on Investment).  
    - CTR (Click-Through Rate).  
    - Конверсия в продажи.  
  - Периодичность отчётов (ежедневно, еженедельно, ежемесячно).  
  - Пороговые значения для уведомлений (например, "CTR ниже 2%").  

---


Этот перечень обеспечивает полноту данных, необходимых для автоматизации маркетинговых процессов, анализа ROI и персонализации взаимодействия с аудиторией.

### <a id="output">3. Перечень выходных данных</a>  
На основе входных данных система предоставляет следующие выходные данные:  

---

#### **1. Отчёты по эффективности маркетинговых кампаний:**  
- **Анализ ROI (Return on Investment):**  
  - Сравнение затрат на кампанию с полученной выручкой.  
  - Рентабельность по каналам продвижения (соцсети, email, баннеры).  
- **Конверсия в продажи:**  
  - Процент клиентов, совершивших покупку после взаимодействия с материалом.  
  - Топ материалов с наивысшей конверсией.  
- **CTR (Click-Through Rate):**  
  - Статистика кликабельности для баннеров и email-рассылок.  
  - Сравнение CTR по разным сегментам аудитории.  

---

#### **2. Статистика по клиентскому поведению:**  
- **Сегментация аудитории:**  
  - Распределение клиентов по категориям: "Новые", "Постоянные", "Неактивные".  
  - Анализ предпочтений (любимые жанры книг, частота покупок).  
- **Динамика продаж:**  
  - Изменение спроса на книги в разрезе жанров и авторов.  
  - Сезонные тренды (например, рост продаж перед праздниками).  

---

#### **3. Отчёты по книгам и авторам:**  
- **Рейтинг продаж:**  
  - Топ-10 самых популярных книг за период.  
  - Сравнение продаж новых изданий с классикой.  
- **Эффективность промо-акций с участием авторов:**  
  - Влияние автограф-сессий или интервью на рост продаж.  
  - Анализ вовлечённости аудитории в мероприятиях.  

---

#### **4. Финансовые сводки:**  
- **Распределение бюджета:**  
  - Затраты на рекламу по каналам (соцсети, email, печать).  
  - Остаток бюджета в реальном времени с учётом текущих расходов.  
- **Прогнозы:**  
  - Рекомендации по оптимальному распределению бюджета на основе исторических данных.  

---

### <a id="limitations">4. Ограничения предметной области</a>  
При работе с системой необходимо учитывать следующие ограничения:  

1. **Ограничение по объёму данных:**  
   - Рост количества кампаний, материалов и клиентов может замедлить выполнение аналитических запросов. Для решения требуется:  
     - Партиционирование таблиц (например, по датам кампаний).  
     - Использование колоночных индексов для ускорения агрегации данных.  

2. **Ограничение по доступу:**  
   - Финансовые данные (бюджеты, ROI) и клиентские персональные данные (email, история покупок) защищены через ролевую модель:  
     - *Администратор* — полный доступ ко всем данным, включая финансовые отчёты.  
     - *Маркетолог* — доступ к своим кампаниям, материалам и обезличенной статистике.  
     - *Клиенты* — доступ только к персонализированным предложениям и истории своих заказов.  

3. **Ограничение по обновлению данных:**  
   - Для предотвращения потерь настроить:  
     - Ежедневное резервное копирование с хранением копий в облаке (AWS S3).  
     - Триггеры для аудита изменений (например, журнал правок в таблице `campaigns`).  

---

### <a id="integration">5. Взаимодействие с другими программами</a>  
Система интегрируется с внешними сервисами для расширения функциональности:  

1. **CRM-системы (например, Bitrix24, Salesforce):**  
   - Синхронизация данных о клиентах и истории покупок.  
   - Автоматический импорт контактов для email-рассылок.  

2. **Платформы аналитики (Power BI, Tableau):**  
   - Маркетологи могут визуализировать метрики эффективности кампаний через интерфейс системы.  
   - Администраторы управляют интеграцией и настройкой дашбордов.  

3. **Электронные торговые площадки (Amazon, Ozon):**  
   - Автоматическое обновление остатков книг на складе при запуске рекламных акций.  
   - Экспорт данных о продажах для анализа конверсии.  

4. **Инструменты автоматизации маркетинга (Mailchimp, SendPulse):**  
   - Маркетологи отправляют персонализированные рассылки через интеграцию.  
   - Треккинг открытий писем и кликов по ссылкам доступен в интерфейсе.  

5. **Социальные сети (Facebook, Instagram):**  
   - Маркетологи загружают баннеры и запускают таргетированную рекламу через API.  

6. **Системы прогнозирования спроса (на основе ML):**  
   - Администраторы настраивают интеграцию для анализа исторических данных.  
   - Прогнозы по тиражам отображаются в разделе для маркетологов.  

---

### Корректировки по ролевой модели:  
- **Администратор:** Полный доступ к данным, включая финансовые отчёты, интеграции и настройку прав.  
- **Маркетолог:** Управление кампаниями, анализ метрик (ROI, CTR), работа с материалами.  
- **Клиент:** Просмотр персонализированных предложений и истории заказов.  


## <a id="infological_model">Инфологическая (концептуальная) модель базы данных</a>  

Концептуальная модель описывает структуру данных для управления маркетинговой деятельностью издательства, включая ключевые сущности, их атрибуты и связи.  

---

### 1. **Выделение информационных объектов**  
- **Кампании (`campaigns`):**  
  Рекламные активности: название, бюджет, сроки, целевая аудитория.  
- **Маркетинговые материалы (`marketing_materials`):**  
  Контент для продвижения: баннеры, email-рассылки, видео.  
- **Книги (`books`):**  
  Издания, участвующие в кампаниях: название, жанр, цена, тираж.  
- **Авторы (`authors`):**  
  Создатели книг, участвующие в промо-акциях.  
- **Клиенты (`customers`):**  
  Покупатели, взаимодействующие с материалами и совершающие заказы.  
- **Заказы (`orders`):**  
  Информация о продажах книг: дата, сумма, количество.  
- **Пользователи (`users`):**  
  Участники системы с ролями: администратор, маркетолог, клиент.  
- **Маркетологи (`marketers`):**  
  Сотрудники, управляющие кампаниями (дополнение к `users`).  
- **Администраторы (`administrators`):**  
  Управление системой и правами (дополнение к `users`).  

---

### 2. **Определение атрибутов объектов**  

#### **Кампании (`campaigns`)**  
| Атрибут            | Тип данных       | Описание                          |  
|---------------------|------------------|-----------------------------------|  
| `campaign_id`       | SERIAL          | Уникальный идентификатор         |  
| `campaign_name`     | VARCHAR(255)    | Название кампании                |  
| `start_date`        | DATE            | Дата начала                      |  
| `end_date`          | DATE            | Дата окончания                   |  
| `budget`            | NUMERIC(12,2)   | Бюджет кампании                  |  
| `target_audience`   | TEXT            | Описание целевой аудитории       |  
| `marketer_id`       | INTEGER         | Ответственный маркетолог         |  

#### **Маркетинговые материалы (`marketing_materials`)**  
| Атрибут            | Тип данных       | Описание                          |  
|---------------------|------------------|-----------------------------------|  
| `material_id`       | SERIAL          | Уникальный идентификатор         |  
| `type`              | VARCHAR(50)     | Тип (баннер, email, видео)       |  
| `content`           | TEXT            | Ссылка или текст контента        |  
| `campaign_id`       | INTEGER         | Привязка к кампании              |  
| `creation_date`     | TIMESTAMP       | Дата создания                    |  

#### **Книги (`books`)**  
| Атрибут            | Тип данных       | Описание                          |  
|---------------------|------------------|-----------------------------------|  
| `book_id`           | SERIAL          | Уникальный идентификатор         |  
| `title`             | VARCHAR(255)    | Название книги                   |  
| `genre`             | VARCHAR(100)    | Жанр                             |  
| `price`             | NUMERIC(10,2)   | Цена                             |  
| `stock`             | INTEGER         | Остаток на складе                |  
| `author_id`         | INTEGER         | Автор книги                      |  

#### **Авторы (`authors`)**  
| Атрибут            | Тип данных       | Описание                          |  
|---------------------|------------------|-----------------------------------|  
| `author_id`         | SERIAL          | Уникальный идентификатор         |  
| `first_name`        | VARCHAR(100)    | Имя автора                       |  
| `last_name`         | VARCHAR(100)    | Фамилия автора                   |  
| `bio`               | TEXT            | Биография                        |  

#### **Клиенты (`customers`)**  
| Атрибут            | Тип данных       | Описание                          |  
|---------------------|------------------|-----------------------------------|  
| `customer_id`       | SERIAL          | Уникальный идентификатор         |  
| `email`             | VARCHAR(255)    | Email                            |  
| `phone`             | VARCHAR(20)     | Телефон                          |  
| `preferred_genres`  | TEXT[]          | Любимые жанры книг               |  

#### **Заказы (`orders`)**  
| Атрибут            | Тип данных       | Описание                          |  
|---------------------|------------------|-----------------------------------|  
| `order_id`          | SERIAL          | Уникальный идентификатор         |  
| `customer_id`       | INTEGER         | Клиент                           |  
| `book_id`           | INTEGER         | Книга                            |  
| `quantity`          | INTEGER         | Количество                       |  
| `order_date`        | TIMESTAMP       | Дата заказа                      |  
| `total_price`       | NUMERIC(10,2)   | Сумма заказа                     |  

#### **Пользователи (`users`)**  
| Атрибут            | Тип данных       | Описание                          |  
|---------------------|------------------|-----------------------------------|  
| `user_id`           | SERIAL          | Уникальный идентификатор         |  
| `username`          | VARCHAR(50)     | Логин                            |  
| `password_hash`     | VARCHAR(255)    | Хеш пароля                       |  
| `role`              | VARCHAR(20)     | Роль (admin, marketer, customer) |  

#### **Маркетологи (`marketers`)**  
| Атрибут            | Тип данных       | Описание                          |  
|---------------------|------------------|-----------------------------------|  
| `marketer_id`       | SERIAL          | Уникальный идентификатор         |  
| `user_id`           | INTEGER         | Ссылка на пользователя           |  
| `department`        | VARCHAR(100)    | Отдел (Digital, SMM, SEO)        |  

#### **Администраторы (`administrators`)**  
| Атрибут            | Тип данных       | Описание                          |  
|---------------------|------------------|-----------------------------------|  
| `admin_id`          | SERIAL          | Уникальный идентификатор         |  
| `user_id`           | INTEGER         | Ссылка на пользователя           |  
| `access_level`      | VARCHAR(50)     | Уровень доступа (полный/частичный)|  

---

### 3. **Определение отношений**  
1. **Кампания → Материалы**  
   - Одна кампания включает **много** материалов (`1:N`).  
   - Связь: `campaigns.campaign_id` → `marketing_materials.campaign_id`.  

2. **Кампания → Маркетолог**  
   - Один маркетолог управляет **многими** кампаниями (`1:N`).  
   - Связь: `marketers.marketer_id` → `campaigns.marketer_id`.  

3. **Книга → Автор**  
   - Один автор пишет **много** книг (`1:N`).  
   - Связь: `authors.author_id` → `books.author_id`.  

4. **Клиент → Заказы**  
   - Один клиент совершает **много** заказов (`1:N`).  
   - Связь: `customers.customer_id` → `orders.customer_id`.  

5. **Заказ → Книга**  
   - Один заказ содержит **одну** книгу (`1:1`), но книга может быть в **многих** заказах (`1:N`).  
   - Связь: `books.book_id` → `orders.book_id`.  

6. **Пользователь → Роль**  
   - Пользователь имеет **одну** роль, но роль может быть у **многих** пользователей (`1:N`).  
   - Связь через поле `users.role`.  

---

### 4. **ER-диаграмма**  
![ER-диаграмма](https://example.com/er-diagram-publisher.png)  
*Рисунок 1. Концептуальная модель для подсистемы маркетинга издательства.*  

---

### 5. **Ограничения целостности**  
- **Уникальность**:  
  - `campaigns.campaign_name` — уникальное название кампании.  
  - `customers.email` — уникальный email клиента.  
- **Проверка значений**:  
  - `campaigns.end_date` ≥ `campaigns.start_date`.  
  - `books.stock` ≥ 0.  
- **Каскадное удаление**:  
  - Удаление кампании → удаление связанных материалов.  

---

Эта модель обеспечивает управление маркетинговыми процессами, анализ ROI и персонализацию взаимодействия с клиентами.

### 4. **Построение концептуальной модели**  
Построение концептуальной модели. На основе выделенных сущностей, их атрибутов и связей между ними можно построить концептуальную ER-диаграмму для базы данных, предназначенной для контроля успеваемости школьников.

![Screenshot_7](https://github.com/user-attachments/assets/f81b4a28-c905-4ced-b28b-c26572c3caa7)

Эта концептуальная модель позволяет наглядно представить структуру базы данных, а также связи между различными сущностями, что упрощает дальнейшее проектирование и реализацию системы контроля успеваемости школьников.

#### <a id="logical_structure">Логическая структура базы данных</a>

Логическая структура базы данных представляет собой детализированное описание таблиц, их атрибутов, типов данных, а также ключевых ограничений и правил целостности. На основе концептуальной модели можно построить логическую структуру, которая будет готова для реализации в системе управления базами данных (СУБД).

В данной структуре будут определены следующие таблицы: **Администраторы**, **Классы**, **Учителя**, **Ученики**, **Предметы**, **Учитель_Предмет**, **Учитель_Класс**, **Оценки**, а также связи между ними.

#### Определение таблиц и их атрибутов

1. **Таблица "Администраторы"**
    - **admin_id** (Primary Key) - уникальный идентификатор администратора (целое число).
    - **login** - логин администратора (строка).
    - **password** - пароль администратора (строка).

    **Типы данных:**
    - admin_id - SERIAL.
    - login - VARCHAR(50).
    - password - VARCHAR(50).

    **Ограничения:**
    - admin_id является уникальным и не может быть NULL.
    - login является уникальным и не может быть NULL.
    - password не может быть NULL.

2. **Таблица "Классы"**
    - **class_id** (Primary Key) - уникальный идентификатор класса (целое число).
    - **class_number** - номер класса (целое число).
    - **class_letter** - буква класса (строка).
    - **start_year** - год начала обучения (дата).

    **Типы данных:**
    - class_id - SERIAL.
    - class_number - INT.
    - class_letter - VARCHAR(5).
    - start_year - DATE.

    **Ограничения:**
    - class_id является уникальным и не может быть NULL.
    - class_number не может быть NULL.
    - class_letter не может быть NULL.
    - start_year не может быть NULL.

3. **Таблица "Учителя"**
    - **teacher_id** (Primary Key) - уникальный идентификатор учителя (целое число).
    - **first_name** - имя учителя (строка).
    - **last_name** - фамилия учителя (строка).
    - **second_name** - отчество учителя (строка).
    - **login** - логин учителя (строка).
    - **password** - пароль учителя (строка).
    - **deleted** - статус удаления (логическое значение).

    **Типы данных:**
    - teacher_id - SERIAL.
    - first_name - VARCHAR(50).
    - last_name - VARCHAR(50).
    - second_name - VARCHAR(50).
    - login - VARCHAR(50).
    - password - VARCHAR(50).
    - deleted - BOOLEAN.

    **Ограничения:**
    - teacher_id является уникальным и не может быть NULL.
    - login является уникальным и не может быть NULL.
    - password не может быть NULL.

4. **Таблица "Ученики"**
    - **student_id** (Primary Key) - уникальный идентификатор ученика (целое число).
    - **first_name** - имя ученика (строка).
    - **last_name** - фамилия ученика (строка).
    - **second_name** - отчество ученика (строка).
    - **date_of_birth** - дата рождения ученика (дата).
    - **class_id** (Foreign Key) - ссылка на таблицу **Классы** (целое число).
    - **history_classes** - история классов (строка).
    - **login** - логин ученика (строка).
    - **password** - пароль ученика (строка).

    **Типы данных:**
    - student_id - SERIAL.
    - first_name - VARCHAR(50).
    - last_name - VARCHAR(50).
    - second_name - VARCHAR(50).
    - date_of_birth - DATE.
    - class_id - INT.
    - history_classes - VARCHAR(8000).
    - login - VARCHAR(50).
    - password - VARCHAR(50).

    **Ограничения:**
    - student_id является уникальным и не может быть NULL.
    - class_id является внешним ключом, который ссылается на таблицу **Классы**.
    - date_of_birth должна быть меньше текущей даты.

5. **Таблица "Предметы"**
    - **subject_id** (Primary Key) - уникальный идентификатор предмета (целое число).
    - **subject_name** - название предмета (строка).

    **Типы данных:**
    - subject_id - SERIAL.
    - subject_name - VARCHAR(50).

    **Ограничения:**
    - subject_id является уникальным и не может быть NULL.
    - subject_name не может быть NULL.

6. **Таблица "Учитель_Предмет"**
    - **teacher_id** (Foreign Key) - ссылка на таблицу **Учителя** (целое число).
    - **subject_id** (Foreign Key) - ссылка на таблицу **Предметы** (целое число).

    **Типы данных:**
    - teacher_id - INT.
    - subject_id - INT.

    **Ограничения:**
    - teacher_id и subject_id вместе образуют составной первичный ключ и не могут быть NULL.

7. **Таблица "Учитель_Класс"**
    - **teacher_id** (Foreign Key) - ссылка на таблицу **Учителя** (целое число).
    - **class_id** (Foreign Key) - ссылка на таблицу **Классы** (целое число).

    **Типы данных:**
    - teacher_id - INT.
    - class_id - INT.

    **Ограничения:**
    - teacher_id и class_id вместе образуют составной первичный ключ и не могут быть NULL.

8. **Таблица "Оценки"**
    - **grade_id** (Primary Key) - уникальный идентификатор оценки (целое число).
    - **student_id** (Foreign Key) - ссылка на таблицу **Ученики** (целое число).
    - **class_id** (Foreign Key) - ссылка на таблицу **Классы** (целое число).
    - **subject_id** (Foreign Key) - ссылка на таблицу **Предметы** (целое число).
    - **teacher_id** (Foreign Key) - ссылка на таблицу **Учителя** (целое число).
    - **grade** - оценка (целое число, допустимые значения: 2, 3, 4, 5).
    - **number_lesson** - номер урока (целое число).
    - **date_lesson** - дата урока (дата).
    - **create_date** - дата создания записи (дата).
    - **update_date** - дата обновления записи (дата).

    **Типы данных:**
    - grade_id - SERIAL.
    - student_id - INT.
    - class_id - INT.
    - subject_id - INT.
    - teacher_id - INT.
    - grade - INT.
    - number_lesson - INT.
    - date_lesson - DATE.
    - create_date - DATE.
    - update_date - DATE.

    **Ограничения:**
    - grade_id является уникальным и не может быть NULL.
    - student_id, class_id, subject_id и teacher_id являются внешними ключами, которые ссылаются на соответствующие таблицы.
    - grade должен быть в диапазоне от 2 до 5.


**Нормализация базы данных**

На данном этапе структура базы данных приведена к третьей нормальной форме (3NF), что позволяет:

- Устранить избыточность данных.
- Избежать аномалий при добавлении, изменении и удалении данных.
- Обеспечить более эффективное использование памяти и более быструю обработку запросов.


## <a id="physical_structure">Физическая структура базы данных</a>

Физическая структура базы данных отвечает за реальное хранение данных на физическом уровне, определяет способы хранения и работы с данными, обеспечивая при этом их целостность, доступность и производительность системы. На этом этапе важно учитывать оптимизацию производительности запросов, объёмы данных и ограничения, связанные с физическим хранением данных в выбранной СУБД. В данной курсовой работе предполагается использование реляционной СУБД (PostgreSQL), так как она предоставляет оптимальные средства для управления табличными данными и поддерживает сложные связи между данными, что необходимо для образовательной организации.

Физическая структура проектируется таким образом, чтобы система максимально эффективно обрабатывала данные, предоставляя пользователю доступ к нужной информации с минимальной задержкой. Это достигается с помощью выбора правильных типов данных, индексов, механизмов хранения и настройки параметров, обеспечивающих производительность и надежность.

1. **Выбор типов данных**

Правильный выбор типов данных для полей таблиц — один из ключевых аспектов проектирования физической структуры базы данных, так как это позволяет экономить ресурсы и повышать производительность.

**Рассмотрим выбор типов данных для каждой таблицы:**

- **SERIAL** — используется для автоинкрементных значений, таких как идентификаторы записей. Это подходит для полей, которые используются как ключи и часто участвуют в соединениях и фильтрации данных.
- **INT** — используется для целочисленных значений, занимает фиксированный объем памяти и обеспечивает эффективное индексирование, что важно для первичных и внешних ключей. Это подходит для полей, которые используются как ключи и часто участвуют в соединениях и фильтрации данных.
- **VARCHAR(n)** — применяется для хранения текстовых данных переменной длины, таких как имена, названия и описания. Этот тип позволяет оптимально расходовать память, так как фактически занимает объем, соответствующий реальной длине строки.
- **DATE** — этот тип данных используется для хранения дат. Он позволяет хранить значения в формате даты (год, месяц, день) и обеспечивает удобные функции для работы с датами, такие как сравнение и вычисление разницы между датами.
- **BOOLEAN** — используется для хранения логических значений, которые могут принимать два состояния: TRUE (истина) или FALSE (ложь). Он часто используется для представления бинарных состояний, таких как наличие или отсутствие, активный или неактивный статус. Например, поле deleted в таблице Teachers указывает, был ли учитель удален.

Тип данных влияет на объем занимаемой памяти и производительность базы данных, так как данные записываются и извлекаются в зависимости от того, какой тип используется.

**Пример SQL-кода с применением типов данных для таблицы "Оценки":**

```
CREATE TABLE Grades (
    grade_id SERIAL PRIMARY KEY,
    student_id INT,
    class_id INT,
    subject_id INT,
    teacher_id INT,
    grade INT CHECK (grade IN (2, 3, 4, 5)),
    number_lesson INT NOT NULL,
    date_lesson DATE NOT NULL,
    create_date DATE NOT NULL,
    update_date DATE default null,
    FOREIGN KEY (student_id) REFERENCES Students(student_id),
    FOREIGN KEY (subject_id) REFERENCES Subjects(subject_id),
    FOREIGN KEY (teacher_id) REFERENCES Teachers(teacher_id),
    FOREIGN KEY (class_id) REFERENCES Classes(class_id)
);
```

2. **Оптимизация индексов**

Индексы являются ключевым элементом в оптимизации базы данных, так как они позволяют ускорить доступ к данным и облегчают выполнение запросов, таких как поиск, фильтрация и сортировка. Индексы создаются для полей, которые часто участвуют в поисковых запросах и соединениях таблиц.

- **Первичные ключи** автоматически индексируются, так как они служат для уникальной идентификации каждой записи. Это гарантирует быстрое выполнение операций поиска и обновления записей.
- **Внешние ключи** (например, student_id, class_id, subject_id, teacher_id) также индексируются, чтобы ускорить выполнение соединений между таблицами. Внешние ключи позволяют поддерживать целостность данных, предотвращая создание записей, не соответствующих связанным данным.
- **Дополнительные индексы** — могут быть добавлены для часто запрашиваемых полей, например, для поля lesson_date в таблице Оценки, если предполагается, что пользователи часто будут искать оценки по дате.

**Создание индексов, используемых в условиях WHERE:**

```
CREATE INDEX idx_students_login ON Students (login);
CREATE INDEX idx_teachers_login ON Teachers (login);
CREATE INDEX idx_classes_class_number_letter ON Classes (class_number, class_letter);
CREATE INDEX idx_grades_student_id ON Grades (student_id);
CREATE INDEX idx_grades_class_id ON Grades (class_id);
CREATE INDEX idx_grades_subject_id ON Grades (subject_id);
CREATE INDEX idx_grades_teacher_id ON Grades (teacher_id);
```

**Создание индексов, используемых в условиях JOIN:**

```
CREATE INDEX idx_teacher_classes_teacher_id ON Teacher_Classes (teacher_id);
CREATE INDEX idx_teacher_subject_teacher_id ON Teacher_Subject (teacher_id);
```

**Создание индексов, используемых в условиях ORDER BY и GROUP BY:**

```
CREATE INDEX idx_grades_date_lesson ON Grades (date_lesson);
CREATE INDEX idx_grades_student_class_subject ON Grades (student_id, class_id, subject_id);
```

**Преимущества индексов:**

- Ускоряют поиск и сортировку.
- Повышают производительность запросов с условиями фильтрации.
- Уменьшают время выполнения операций соединения.

**Недостаток индексов:**
- Индексы занимают место и могут замедлить операции вставки, обновления и удаления, так как индексы также нужно обновлять.

3. **Таблицы и кластеризация данных**

Кластеризация позволяет физически упорядочивать записи на диске по значению индекса, что может существенно ускорить выполнение запросов, в которых данные фильтруются и сортируются по определенному столбцу. Например, таблицу Оценки можно упорядочить по lesson_date, чтобы данные о занятиях находились физически рядом. Это улучшает производительность запросов, касающихся конкретных уроков, так как чтение данных с диска выполняется быстрее.

4. **Механизм хранения и параметры оптимизации**

PostgreSQL использует механизм хранения данных, поддерживающий многоверсионность (MVCC, Multiversion Concurrency Control), что позволяет эффективно управлять транзакциями и конкурентным доступом к данным. В отличие от MySQL, PostgreSQL не требует явного указания механизма хранения при создании таблиц, так как все таблицы автоматически используют встроенный механизм. Этот механизм обеспечивает высокий уровень надежности, особенно для данных, подверженных частым изменениям, и поддерживает управление транзакциями, что критично для точности и согласованности данных.

**Преимущества MVCC в PostgreSQL для базы данных**

- **Поддержка транзакций** — гарантирует согласованность данных. Каждая транзакция выполняется как отдельная операция, и в случае неудачи все изменения отменяются.
- **Конкурентный доступ** — PostgreSQL позволяет нескольким пользователям одновременно работать с данными, обеспечивая при этом изоляцию транзакций, что делает его особенно подходящим для высоконагруженных приложений, где требуется частое обновление данных.
- **Гибкое управление блокировками** — позволяет предотвращать конфликты между транзакциями и поддерживает высокую производительность.

**Особенности PostgreSQL при создании таблиц:**

- **Тип SERIAL** — используется для создания автоинкрементных первичных ключей. В PostgreSQL SERIAL автоматически создает последовательность и обеспечивает уникальные значения для каждого нового элемента, что упрощает настройку первичных ключей.
- **CHECK-ограничения** — PostgreSQL поддерживает гибкие ограничения, которые помогают контролировать значения в полях. Например, ограничения на поле **Оценка** гарантирует, что значения будут только 2, 3, 4 или 5.

5. **Политики управления целостностью данных**

PostgreSQL предоставляет богатый функционал для поддержания целостности данных с использованием различных ограничений и ключей. Эти механизмы помогают гарантировать, что база данных всегда находится в согласованном состоянии.

**Основные элементы для управления целостностью:**

- **Первичные ключи (PRIMARY KEY)** — используются для уникальной идентификации записей в таблицах. В PostgreSQL первичные ключи создаются с использованием уникального индекса и автоматически проверяют уникальность значения.
- **Внешние ключи (FOREIGN KEY)** — обеспечивают целостность ссылочной структуры между таблицами. Внешние ключи используются, чтобы установить зависимость между записями. Например, в таблице Оценки внешний ключ student_id гарантирует, что ученик будет существовать в таблице Ученики.
- **Ограничения NOT NULL** — применяются к полям, значения в которых обязательно должны быть указаны. Поля, такие как grade и lesson_date, не могут быть пустыми, так как эти данные являются обязательными для бизнес-процессов.
- **CHECK-ограничения** — применяются для контроля значений полей в соответствии с установленными правилами. Например, в поле grade вводятся только значения 2, 3, 4 или 5, что соответствует оценочной системе.

```
CREATE TABLE Students (
    student_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    date_of_birth DATE NOT NULL,
    class_id INT NOT NULL,
    CHECK (date_of_birth < CURRENT_DATE),
    FOREIGN KEY (class_id) REFERENCES Классы(class_id)
);
```

В этом примере используется регулярное выражение для проверки, что дата рождения должна быть раньше нынешней даты.

**Другие механизмы управления целостностью:**

- **Триггеры** — PostgreSQL поддерживает триггеры, которые позволяют выполнять дополнительные проверки и операции при добавлении, обновлении или удалении записей. Триггеры могут использоваться для автоматической записи истории изменений или для сложных проверок целостности, когда стандартных ограничений недостаточно.
- **Индексы** — PostgreSQL автоматически создает индексы для полей, которые заданы как первичные ключи или уникальные. Это улучшает производительность запросов, так как индекс ускоряет поиск и доступ к данным.
- **Управление транзакциями** — PostgreSQL поддерживает уровни изоляции транзакций, которые позволяют определять правила работы с параллельными запросами.

Таким образом, механизмы управления целостностью в PostgreSQL обеспечивают надежную работу базы данных, поддерживая высокую степень согласованности и производительности.

6. **Параметры хранения и резервное копирование**

Для обеспечения надежности базы данных образовательной организации и защиты от потерь данных, в PostgreSQL необходимо организовать систему резервного копирования и продумать параметры хранения. PostgreSQL предлагает несколько методов резервного копирования и восстановления данных, а также настройки, которые влияют на производительность и безопасность системы.

**Резервное копирование**

PostgreSQL поддерживает два основных типа резервного копирования:

- **Логическое резервное копирование** — выполняется с помощью утилиты pg_dump. Этот метод позволяет копировать структуру и данные одной или нескольких баз данных. Логическое копирование используется в ситуациях, когда требуется гибкость, например, для восстановления на другой версии PostgreSQL или для миграции данных.

Пример использования pg_dump для создания резервной копии:

```
pg_dump -U username -F c -b -v -f "backup_filename.backup" database_name
```

Этот скрипт сохраняет базу данных в формате архивного файла, который затем можно будет использовать для восстановления.

- **Физическое резервное копирование** — выполняется путем копирования файлов данных на уровне файловой системы. PostgreSQL предоставляет инструмент pg_basebackup, который выполняет копирование всех файлов базы данных и создаёт полную копию в заданном каталоге.

Пример использования pg_basebackup:

```
pg_basebackup -U postgres -D /path/to/backup -Ft -z -P
```

Физическое резервное копирование особенно полезно для больших баз данных и высоконагруженных систем, так как оно позволяет быстрее восстанавливать данные и поддерживать согласованность на уровне файлов.

7. **SQL-код создания таблиц с физической структурой для PostgreSQL**

В этом разделе приводится полный пример SQL-кода для создания таблиц, описанных в предыдущих разделах. Каждая таблица строится с учетом требований физической структуры базы данных и с использованием всех механизмов PostgreSQL для оптимизации, поддержки целостности и обеспечения надежности данных.

```
-- Создание таблицы Администраторы
CREATE TABLE Admins (
    admin_id SERIAL PRIMARY KEY,
    login VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(50) NOT NULL
);


-- Создание таблицы Классы
CREATE TABLE Classes (
    class_id SERIAL PRIMARY KEY,
    class_number INT NOT NULL,
    class_letter VARCHAR(5) NOT null,
    start_year DATE NOT NULL
);

-- Создание таблицы Учителя
CREATE TABLE Teachers (
    teacher_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    second_name VARCHAR(50) NOT null,
    login VARCHAR(50) UNIQUE NOT NULL,
  password VARCHAR(50) NOT NULL,
  deleted BOOLEAN NOT NULL DEFAULT FALSE
);

-- Создание таблицы Ученики
CREATE TABLE Students (
    student_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    second_name VARCHAR(50) NOT NULL,
    date_of_birth DATE NOT NULL,
    class_id INT,
    history_classes VARCHAR(8000) DEFAULT NULL,
    login VARCHAR(50) UNIQUE NOT NULL,
  password VARCHAR(50) NOT NULL,
    CHECK (date_of_birth < CURRENT_DATE),
    FOREIGN KEY (class_id) REFERENCES Classes(class_id)
);

-- Создание таблицы Предметы
CREATE TABLE Subjects (
    subject_id SERIAL PRIMARY KEY,
    subject_name VARCHAR(50) NOT NULL
);

-- Создание таблицы Учитель_Предмет
CREATE TABLE Teacher_Subject (
    teacher_id INT,
    subject_id INT,
    PRIMARY KEY (teacher_id, subject_id),
    FOREIGN KEY (teacher_id) REFERENCES Teachers(teacher_id),
    FOREIGN KEY (subject_id) REFERENCES Subjects(subject_id)
);

-- Создание таблицы Учитель_Класс
CREATE TABLE Teacher_Classes (
    teacher_id INT,
    class_id INT,
    PRIMARY KEY (teacher_id, class_id),
    FOREIGN KEY (teacher_id) REFERENCES Teachers(teacher_id),
    FOREIGN KEY (class_id) REFERENCES Classes(class_id)
);


-- Создание таблицы Оценки
CREATE TABLE Grades (
    grade_id SERIAL PRIMARY KEY,
    student_id INT,
    class_id INT,
    subject_id INT,
    teacher_id INT,
    grade INT CHECK (grade IN (2, 3, 4, 5)),
    number_lesson INT NOT NULL,
    date_lesson DATE NOT NULL,
    create_date DATE NOT NULL,
    update_date DATE default null,
    FOREIGN KEY (student_id) REFERENCES Students(student_id),
    FOREIGN KEY (subject_id) REFERENCES Subjects(subject_id),
    FOREIGN KEY (teacher_id) REFERENCES Teachers(teacher_id),
    FOREIGN KEY (class_id) REFERENCES Classes(class_id)
);


-- Индексы для оптимизации запросов
CREATE INDEX idx_students_login ON Students (login);
CREATE INDEX idx_teachers_login ON Teachers (login);
CREATE INDEX idx_classes_class_number_letter ON Classes (class_number, class_letter);
CREATE INDEX idx_grades_student_id ON Grades (student_id);
CREATE INDEX idx_grades_class_id ON Grades (class_id);
CREATE INDEX idx_grades_subject_id ON Grades (subject_id);
CREATE INDEX idx_grades_teacher_id ON Grades (teacher_id);
CREATE INDEX idx_teacher_classes_teacher_id ON Teacher_Classes (teacher_id);
CREATE INDEX idx_teacher_subject_teacher_id ON Teacher_Subject (teacher_id);
CREATE INDEX idx_grades_date_lesson ON Grades (date_lesson);
CREATE INDEX idx_grades_student_class_subject ON Grades (student_id, class_id, subject_id);
```

**Описание и обоснование SQL-кода**

- **Создание таблиц:** Каждая таблица создается с использованием типа SERIAL для первичного ключа, который обеспечивает автоинкремент и уникальность записи. Поля, содержащие важные текстовые данные, используются с типом VARCHAR, а для целочисленных значений и дат применяется тип INT и DATE соответственно.
- **Ограничения целостности:** В таблицах установлены внешние ключи для обеспечения ссылочной целостности. Например, class_id в таблице Students ссылается на таблицу Classes, что гарантирует, что каждый ученик будет принадлежать к существующему классу.
- **Индексы:** Добавлены индексы для полей, которые часто участвуют в запросах.
- **CHECK-ограничения:** Дополнительные ограничения установлены на такие поля, как grade, чтобы защитить базу данных от некорректных значений и обеспечить соответствие данных бизнес-логике.

Этот SQL-код и структура таблиц обеспечивают надежную физическую реализацию базы данных в PostgreSQL для образовательной организации, удовлетворяя всем требованиям по целостности, производительности и масштабируемости.

#### <a id="project_realization">Реализация проекта в среде конкретной СУБД</a>

Этот раздел курсовой работы описывает практическую реализацию базы данных в PostgreSQL. Рассматриваются основные этапы — от создания таблиц и запросов до разработки интерфейса, индексов и резервного копирования.

1. **Создание таблиц и индексов**


```
SQL-код публиковался выше
```

2. **Создание представлений и функций**

- **Для удобства работы, реализовано представления для оценок и для классов, которые ведет учитель:**
- 
```
CREATE OR REPLACE VIEW student_grades AS
SELECT
    g.grade_id,
    s.student_id,
    s.first_name AS student_first_name,
    s.last_name AS student_last_name,
    sub.subject_name,
    g.grade,
    g.create_date,
    c.class_number,
    c.class_letter,
    g.class_id,
    g.subject_id,
    g.date_lesson
FROM
    Grades g
JOIN
    Students s ON g.student_id = s.student_id
JOIN
    Subjects sub ON g.subject_id = sub.subject_id
JOIN
    Classes c ON g.class_id = c.class_id;
```

```
CREATE OR REPLACE VIEW Teacher_Classes_View AS
SELECT 
    tc.teacher_id,
    c.class_id,
    c.class_number,
    c.class_letter
FROM 
    Teacher_Classes tc
JOIN 
    Classes c ON tc.class_id = c.class_id;

```


- **Функция для добавление оценки:**

```
CREATE OR REPLACE FUNCTION add_grade(
    p_student_id INT,
    p_class_id INT,
    p_subject_id INT,
    p_teacher_id INT,
    p_grade INT,
    p_number_lesson INT,
    p_date_lesson DATE,
    p_create_date DATE
) RETURNS VOID AS $$
BEGIN
    INSERT INTO Grades (student_id, class_id, subject_id, teacher_id, grade, number_lesson, date_lesson, create_date)
    VALUES (p_student_id, p_class_id, p_subject_id, p_teacher_id, p_grade, p_number_lesson, p_date_lesson, p_create_date);
END;
$$ LANGUAGE plpgsql;
```

- **Функция для изменения оценки:**

```
CREATE OR REPLACE FUNCTION update_grade(
    p_grade_id INT,
    p_new_grade INT
) RETURNS VOID AS $$
BEGIN
    UPDATE Grades
    SET grade = p_new_grade, update_date = CURRENT_DATE
    WHERE grade_id = p_grade_id;
END;
$$ LANGUAGE plpgsql;

```

3. **Разработка интерфейса**

Интерфейс для взаимодействия с базой данных будем создавать с помощью инструментов построения интерфейсов в Python, таких как tkinter. **Основные функции интерфейса должны включать:**

- **Авторизацию** — авторизация под учеником, учителем или администратором.
- **Отображение существующих оценок** — табели оценок, оценки конкретного ученика.
- **Добавление и обновление данных** — формы для изменения оценок у учеников.
- **Анализ данных** — сравнительный анализ успеваемости учащихся.

На языке Python и tkinter можно создать простое приложение, выполняющее данные функции.

4. **Назначение прав доступа**

В целях безопасности база данных может иметь следующие роли:

- **Администратор** — имеет возможность добавлять удалять учителей, редактировать зоны отвественности учителей.
- **Учитель** — может обновлять и контроллировать успеваемость прикрепленных к нему классов, только по тем предметам которые ведет данный учитель.
- **Ученик** — может только просматривать информацию о своих оценках.


5. **Разработка стратегии резервного копирования базы данных**

Для защиты данных от сбоев и потерь необходимо разработать стратегию регулярного резервного копирования. Для PostgreSQL основными методами являются:

- **Ежедневное логическое резервное копирование с помощью pg_dump** — позволяет создавать бэкап базы данных в формате SQL. Эти резервные копии можно хранить на удаленном сервере или в облаке.

Пример ежедневного резервного копирования:

```
pg_dump -U postgres -F c -b -v -f "/backups/backup_$(date +\%Y\%m\%d).backup" postgres
```

- **Полное физическое резервное копирование раз в неделю с использованием pg_basebackup** — особенно полезно для больших объемов данных, так как обеспечивает быстрое восстановление базы данных.

Пример команды:

```
pg_basebackup -U postgres -D /path/to/backup -Ft -z -P
```

- **Проверка и тестирование восстановлений** — резервное копирование должно регулярно тестироваться на восстановление, чтобы убедиться в работоспособности резервных копий. Это критически важно для обеспечения постоянной доступности и надежности данных.

Стратегия резервного копирования должна включать хранение нескольких копий данных на случай различных инцидентов, таких как сбой оборудования или ошибка администратора.

### <a id="conclusion">Заключение</a>

В результате выполнения курсовой работы была разработана база данных для контроля успеваемости школьников, которая отвечает современным требованиям образовательного процесса. Основные достижения и выводы работы:

- **Анализ предметной области**: Проведен детальный анализ существующих методов учета успеваемости, что позволило выявить ключевые проблемы и требования пользователей к системе.

- **Проектирование структуры базы данных**: Создана логическая и физическая структура базы данных, включающая таблицы для администраторов, классов, учителей, учеников, предметов и оценок. Все таблицы нормализованы до третьей нормальной формы, что обеспечивает целостность и согласованность данных.

- **Реализация функционала**: Разработаны функции для ввода и обновления данных, а также представления для анализа успеваемости. Это позволяет пользователям легко управлять информацией и получать необходимые отчеты.

- **Обеспечение безопасности**: Внедрена система прав доступа, что гарантирует защиту конфиденциальной информации о школьниках и их успеваемости.

- **Тестирование и документация**: Проведено тестирование базы данных на корректность выполнения операций и целостность данных. Подготовлена техническая документация, что обеспечит удобство в использовании системы и поможет в обучении новых пользователей.

Таким образом, разработанная база данных является эффективным инструментом для управления успеваемостью школьников, что способствует оптимизации учебного процесса и повышению качества образования.

## <a id="literature">Список использованных информационных источников</a>

1. **Онлайн-ресурсы:**
   - PostgreSQL. (n.d.). *PostgreSQL Documentation*. Retrieved from [https://www.postgresql.org/docs/](https://www.postgresql.org/docs/)
   - PGdocs. (n.d.). *Введние в представления*. Retrieved from [https://pgdocs.ru/gruber/ch20.html](https://pgdocs.ru/gruber/ch20.html)
   - Хабр. (n.d.). *Индексы в PostgreSQL*. Retrieved from [https://habr.com/ru/companies/postgrespro/articles/326096/](https://habr.com/ru/companies/postgrespro/articles/326096/)
   - SQL-Ex blog. (n.d.). *Функции PostgreSQL: сила функций пользователя*. Retrieved from [https://sql-ex.com/blogs/?/Funkcii_PostgreSQL_sila_funkcij_polzovatelJa.html](https://sql-ex.com/blogs/?/Funkcii_PostgreSQL_sila_funkcij_polzovatelJa.html)

2. **Справочные системы:**
   - DBeaver. (n.d.). *DBeaver Documentation*. Retrieved from [https://dbeaver.com/docs/dbeaver/](https://dbeaver.com/docs/dbeaver/)
   - docs.python.org. (n.d.). *tkinter Documentation*. Retrieved from [https://docs.python.org/3/library/tkinter.html](https://docs.python.org/3/library/tkinter.html)
   - Psycopg. (n.d.). *Psycopg – PostgreSQL database adapter for Python*. Retrieved from [https://www.psycopg.org/docs/](https://www.psycopg.org/docs/)

## <a id="applications">Приложения</a>

В данном разделе представлены приложения, использованные в курсовой работе.

#### Приложение 1: Код приложения на Python

В этом приложении представлен код, написанный на tkinter и psycopg2, Python для взаимодействия с базой данных.

[Код приложения на Python](/visual.py)

#### Приложение 2: Презентация

Презентация, подготовленная для защиты курсовой работы, содержит основные моменты и выводы.

[Презентация](/presentation.pptx)

#### Приложение 3: Текстовая речь

Текстовая версия речи, произнесенной во время защиты курсовой работы, доступна в формате .txt

[Текст речи](/text.txt)

#### Приложение 4: SQL-запросы на заполнение таблиц

В этом приложении представлены SQL-запросы для импорта данных в таблицы, использованные в процессе разработки базы данных.

[SQL-запросы](/sql.sql)

[Вернуться к содержанию](#content)